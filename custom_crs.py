"""
The script defines functions that can be used in the QGIS python console to speed up the generation of custom projections 
for the region of interest, including:
- Orthographic projection (i.e. view from space) 
- Satellite view (a.k.a. tilted perspective projection or general perspective)
- Lambert azimuthal equal-area projection (LAEA)
- Lambert conformal conic (LCC)
- Albers equal-area conic projection
- Robinson / Miller / Mollweide / Winkel Tripel or other projections centered on the Pacific or any custom longitude

For example, the following line creates a custom CRS (and an autogenerated description of the CRS) that mimics the view of Peru 
from a satellite in a height of 5500 km above 25°S, 70°W, looking towards -20° from north direction with a tilt of 30° away from nadir
(nice for small insets showing the area of interest): 

crs, desc = crs_sat(-25, -70, h=5500000, azi=-20, tilt=30, setproject=True) 

With setproject=True, the CRS of the project is set accordingly. This makes it very easy to adjust the values and to find 
the best angles. To save the CRS, pass the option savecrs=True while creating the custom crs or call the function save_crs(crs, desc) with an existing one.

The class AreaOfInterest() provides an alternative approach. To define your area 
of interest, either choose a layer comprising only your area (the layer extend 
will be used) or select some features of a vector layer (the bounding box of 
selected features will be used). Now initiate an instance of the class:

aoi = AreaOfInterest()

And create a Lambert azimuthal equal-area projection centered of the center of 
the area of interest with:

crs = aoi.laea()

This already sets the project CRS to the newly created CRS. To change this 
behavior, set 

aoi.setproject = False 

It is possible to override certain attributes and to round the values. For an 
Albers projection with standard parallels rounded to 2 digits and longitude 
centered on 0°:

aoi.albers(lon_0=0, round_digits=2)

You can save the CRS that was created last as user CRS to be used in other projects:

aoi.save_crs()

"""

def crs_orthographic(lat, lon, setproject=False, savecrs=False):
    """
    Create a custom orthographic projection centered on lat, lon. 
    
    This projections mimics the view of earth from space from infinite distance.
    Parameters:
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=ortho +lat_0={lat} +lon_0={lon} +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs'
    description = f"Orthographic lat {lat}, lon {lon}"

    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
    
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description


def crs_sat(lat=40, lon=0, h=5000000, azi=0, tilt=0, setproject=False, savecrs=False):
    """
    Create a custom tilted perspective projection centered on lat, lon. 
    
    This projections mimics the view of earth from a satellite in h meters altitude. 
    Nice for insets showing the area of interest. For best results, only use the upper 
    part of the resulting "globe" and eventually also rotate the map view.
    Parameters:
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        h (int): altitude in meters 
        azi (float): Bearing in degrees away from north
        tilt (float): Angle in degrees away from nadir
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=tpers +lat_0={lat} +lon_0={lon} +h={h} +tilt={tilt} +azi={azi} +ellps=sphere +x_0=0 +y_0=0 +units=m'
    # proj4 = f'+proj=nsper +lat_0={lat} +lon_0={lon} +h={h} +x_0=0 +y_0=0 +units=m'
    km = int(h/1000)
    description = f"Tilted Perspective lat {lat}, lon {lon}, h {km}k, azi {azi}, tilt {tilt}"

    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description


def crs_laea(lat, lon, setproject=False, savecrs=False):
    """
    Create a custom Lambert azimuthal equal-area projection centered on lat, lon. 
    
    Parameters:
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=laea +lat_0={lat} +lon_0={lon} +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
    description = f"LAEA centered on lat {lat}, lon {lon}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description   

def crs_pacific(projection='robin', lon=-150, setproject=False, savecrs=False):
    """
    Create a custom Robinson / Mollweide / Miller / Winkel Tripel etc. projection centered on a given lon. 
    
    On-the-fly reprojection of layers can result in artifacts, better to reproject the layers to this crs.
    Parameters:
        projection (str): Projection 
            use proj4 code such as: 
            'robin' (Robinson)
            'wintri' (Winkel Tripel)
            'mill' (Miller)
            'moll' (Mollweide)
            Using an invalid projection (string) raises a ValueError.
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj={projection} +lon_0={lon} +x_0=0 +y_0=0 +datum=WGS84 +ellps=WGS84 +units=m +no_defs'
    description = f"Custom {projection} centered on lon {lon}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if not crs.isValid():
        #print("Invalid CRS")
        raise ValueError("Invalid CRS")
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description  

def crs_lcc(lat_1=33, lat_2=45, lon_0=0, setproject=False, savecrs=False):
    """
    Create a custom Lambert conformal conic (LCC)  projection with standard parallels lat_1 and lat_2. 
    
    Parameters:
        lat_1 (float): First standard parallel (degrees)
        lat_2 (float): Second standard parallel (degrees)
        lon_0=0 (float): Longitude of map center (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=lcc +lon_0={lon_0} +lat_1={lat_1} +lat_2={lat_2} +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
    description = f"LCC w. parallels {lat_1}, {lat_2}, centered lon {lon_0}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description   




def crs_albers(lat_1, lat_2, lon_0=0, setproject=False, savecrs=False):
    """
    Create a custom Albers equal-area conic projection with standard parallels lat_1 and lat_2. 
    
    Note: The greatest accuracy is obtained if the selected standard parallels enclose two-thirds the height of the map.
    Parameters:
        lat_1 (float): First standard parallel (degrees)
        lat_2 (float): Second standard parallel (degrees)
        lon_0=0 (float): Longitude of map center (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=aea +lon_0={lon_0} +lat_1={lat_1} +lat_2={lat_2} +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
    description = f"Albers w. parallels {lat_1}, {lat_2}, centered lon {lon_0}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description   
  
    
def set_project_crs(crs):
    """Set the project crs. Parameter: crs (QgsCoordinateReferenceSystem)"""
    if crs.isValid():
        QgsProject.instance().setCrs(crs)
        print("Project CRS has been changed")
    else:
        print("Invalid CRS")
        
def save_crs(crs, description):
    """
    Save a crs in the user crs database.
    
    A valid CRS that is not yet in the database will be saved to the user database
    Parameters:
        crs (QgsCoordinateReferenceSystem)
        Description (str)
    """
    if not crs.isValid():
        print("Invalid CRS")
    elif crs.findMatchingProj():
        print("CRS already in Database")
    else:
        success = crs.saveAsUserCrs(description)
        if success:
            print("Succesfully saved CRS")
        else:
            print("Could not save CRS")

def get_project_crs():
    """Shortcut to get current project CRS. Returns: crs (QgsCoordinateReferenceSystem)"""
    return QgsProject.instance().crs()
    
class AreaOfInterest():
    """
    Rectangular area of interest with methods to create matching custom CRS.
    
    Area of Interest is the extent of the active layer, or, 
    if features are selected, the bounding box of these features.
    
    Methods:
        orthographic: Return custom orthographic projection.
        sat: Return custom satellite view projection.
        laea: Return custom Lambert azimuthal equal-area projection.
        lcc: Return custom Lambert conformal conic projection.
        albers: Return custom Albers equal-area conic projection.
        save_crs: Save the crs that was created last. 
    
    Attributes:
        box: Area of Interest as QgsRectangle.
        center: Center of the Area of Interest (QgsPointXY).
        lon: Longitude of central point (float).
        lat: Latitude of central point (float).
        lat_1, lat_2: Two standard parallel enclosing 2/3 of the AOI (float).
        crs: The last CRS that was created.
        crs_desc: Description of the last CRS that was created.
        setproject: Boolean, default is True, set to false if you don't want to set the project CRS while creating a custom CRS.
    """
        
    
    def __init__(self):
        layer = iface.activeLayer()
        if isinstance(layer, QgsVectorLayer) and layer.selectedFeatureCount() > 0:
            self.box = layer.boundingBoxOfSelected()
        else:
            self.box = layer.extent()
        
        self.center = self.box.center()
        self.lon = self.center.x()
        self.lat = self.center.y()
        
        # Keep reference of the last created CRS
        self.crs = None
        self.crs_desc = None
        
        # Set the project CRS to newly created CRS?
        self.setproject = True
        
        # Define two standard parallels enclosing 2/3 of the AOI
        
        self.lat_1 = self.box.yMaximum() - (self.box.height() / 6)
        self.lat_2 = self.box.yMinimum() + (self.box.height() / 6)
        
    def orthographic(self, lat=None, lon=None, round_digits=None):
        """
        Create a custom orthographic projection. 
        
        This projections mimics the view of earth from space from infinite distance.
        Default: Centered on center of the area of interest. 
        Parameters can be used to overwrite the default values.
        Parameters:
            lat (float): Latitude (degrees), optional.
            lon (float): Longitude (degrees), optional.
            round_digits (int): optionally round lat, lon values.  

        Returns:
            crs (QgsCoordinateReferenceSystem)
        """
        # The default values are taken from the AOI attributes
        # but we allow to override them
        if not lat:
            lat = self.lat
        if not lon:
            lon = self.lon
        
        #Optionally round digits
        if round_digits != None:
            lat = round(lat, round_digits)
            lon = round(lon, round_digits)
        
        self.crs, self.crs_desc = crs_orthographic(lat=lat, lon=lon, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs
        
    def sat(self, lat=None, lon=None, h=5000000, azi=0, tilt=0, round_digits=None):
        """
        Create a custom tilted perspective projection.
        
        This projections mimics the view of earth from a satellite in h meters altitude. 
        Nice for insets showing the area of interest. For best results, only use the upper 
        part of the resulting "globe" and eventually also rotate the map view.
        Default: Centered on center of the area of interest. 
        Parameters can be used to overwrite the default values.
        Parameters:
            lat (float): Latitude (degrees), optional.
            lon (float): Longitude (degrees), optional.
            h (int): altitude in meters 
            azi (float): Bearing in degrees away from north
            tilt (float): Angle in degrees away from nadir
            round_digits (int): optionally round lat, lon values.  

        Returns:
            crs (QgsCoordinateReferenceSystem)
        """

        if not lat:
            lat = self.lat
        if not lon:
            lon = self.lon

        #Optionally round digits
        if round_digits != None:
            lat = round(lat, round_digits)
            lon = round(lon, round_digits)
        
        self.crs, self.crs_desc = crs_sat(lat=lat, lon=lon, h=h, azi=azi, tilt=tilt, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs 
        
    def laea(self, lat=None, lon=None, round_digits=None):
        """
        Create a custom Lambert azimuthal equal-area projection. 
        
        Default: Centered on center of the area of interest. 
        Parameters can be used to overwrite the default values.
        Parameters:
            lat (float): Latitude of projection center (degrees)
            lon (float): Longitude of projection center (degrees)
            round_digits (int): optionally round lat, lon values. 
        Returns:
            crs (QgsCoordinateReferenceSystem)
        """
        if not lat:
            lat = self.lat
        if not lon:
            lon = self.lon

        #Optionally round digits
        if round_digits != None:
            lat = round(lat, round_digits)
            lon = round(lon, round_digits) 
        
        self.crs, self.crs_desc = crs_laea(lat=lat, lon=lon, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs    
    
    def lcc(self, lat_1=None, lat_2=None, lon_0=None, round_digits=None):
        """
        Create a custom Lambert conformal conic (LCC)  projection. 
        
        Default: Standard parallels enclose 2/3 of the area of interest and 
        lon_0 is longitude of central point of area of interest. 
        Parameters can be used to overwrite the default values.
        Parameters:
            lat_1 (float): Optional, first standard parallel (degrees)
            lat_2 (float): Optional, second standard parallel (degrees)
            lon_0 (float): Longitude of map center (degrees)
            round_digits (int): optionally round lat, lon values. 
        Returns:
            crs (QgsCoordinateReferenceSystem)
        """
        if not lat_1:
            lat_1 = self.lat_1
        if not lat_2:
            lat_2 = self.lat_2
        if not lon_0:
            lon_0 = self.lon

        #Optionally round digits
        if round_digits != None:
            lat_1 = round(lat_1, round_digits)
            lat_2 = round(lat_2, round_digits)
            lon_0 = round(lon_0, round_digits) 
        
        self.crs, self.crs_desc = crs_lcc(lat_1=lat_1, lat_2=lat_2, lon_0=lon_0, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs  
    
    
    def albers(self, lat_1=None, lat_2=None, lon_0=None, round_digits=None):
        """
        Create a custom Albers equal-area conic projection. 
        
        Default: Standard parallels enclose 2/3 of the area of interest and 
        lon_0 is longitude of central point of area of interest. 
        Parameters can be used to overwrite the default values.
        Parameters:
            lat_1 (float): Optional, first standard parallel (degrees)
            lat_2 (float): Optional, second standard parallel (degrees)
            lon_0 (float): Longitude of map center (degrees)
            round_digits (int): optionally round lat, lon values. 
        Returns:
            crs (QgsCoordinateReferenceSystem)
        """
        if not lat_1:
            lat_1 = self.lat_1
        if not lat_2:
            lat_2 = self.lat_2
        if not lon_0:
            lon_0 = self.lon

        #Optionally round digits
        if round_digits != None:
            lat_1 = round(lat_1, round_digits)
            lat_2 = round(lat_2, round_digits)
            lon_0 = round(lon_0, round_digits) 
        
        self.crs, self.crs_desc = crs_albers(lat_1=lat_1, lat_2=lat_2, lon_0=lon_0, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs 
        
    def save_crs(self):
        save_crs(self.crs, self.crs_desc)

    