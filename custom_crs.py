"""
The script defines functions that can be used in the QGIS python console to speed up the generation of custom projections 
for the region of interest, including:
- Orthographic projection (i.e. view from space) 
- Satellite view (a.k.a. tilted perspective projection or general perspective)
- Lambert azimuthal equal-area projection (LAEA)
- Albers equal-area conic projection
- Robinson / Miller / Mollweide / Winkel Tripel or other projections centered on the Pacific or any custom longitude

For example, the following line creates a custom CRS (and an autogenerated description of the CRS) that mimics the view of Peru 
from a satellite in a height of 5500 km above 25째S, 70째W, looking towards -20째 from north direction with a tilt of 30째 away from nadir
(nice for small insets showing the area of interest): 

crs, desc = crs_sat(-25, -70, h=5500000, azi=-20, tilt=30, setproject=True) 

With setproject=True, the CRS of the project is set accordingly. This makes it very easy to adjust the values and to find 
the best angles. To save the CRS, pass the option savecrs=True while creating the custom crs or call the function save_crs(crs, desc) with an existing one.
"""

def crs_orthographic(lat, lon, setproject=False, savecrs=False):
    """
    Create a custom orthographic projection centered on lat, lon. 
    
    This projections mimics the view of earth from space from infinite distance.
    Parameters:
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=ortho +lat_0={lat} +lon_0={lon} +x_0=0 +y_0=0 +ellps=sphere +units=m +no_defs'
    description = f"Orthographic lat {lat}, lon {lon}"

    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
    
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description


def crs_sat(lat=40, lon=0, h=5000000, azi=0, tilt=0, setproject=False, savecrs=False):
    """
    Create a custom tilted perspective projection centered on lat, lon. 
    
    This projections mimics the view of earth from a satellite in h meters altitude. 
    Nice for insets showing the area of interest. For best results, only use the upper 
    part of the resulting "globe" and eventually also rotate the map view.
    Parameters:
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        h (int): altitude in meters 
        azi (float): Bearing in degrees away from north
        tilt (float): Angle in degrees away from nadir
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=tpers +lat_0={lat} +lon_0={lon} +h={h} +tilt={tilt} +azi={azi} +ellps=sphere +x_0=0 +y_0=0 +units=m'
    # proj4 = f'+proj=nsper +lat_0={lat} +lon_0={lon} +h={h} +x_0=0 +y_0=0 +units=m'
    km = int(h/1000)
    description = f"Tilted Perspective lat {lat}, lon {lon}, h {km}k, azi {azi}, tilt {tilt}"

    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description


def crs_laea(lat, lon, setproject=False, savecrs=False):
    """
    Create a custom Lambert azimuthal equal-area projection centered on lat, lon. 
    
    Parameters:
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=laea +lat_0={lat} +lon_0={lon} +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
    description = f"LAEA centered on lat {lat}, lon {lon}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description   

def crs_pacific(projection='robin', lon=-150, setproject=False, savecrs=False):
    """
    Create a custom Robinson / Mollweide / Miller / Winkel Tripel etc. projection centered on a given lon. 
    
    On-the-fly reprojection of layers can result in artifacts, better to reproject the layers to this crs.
    Parameters:
        projection (str): Projection 
            use proj4 code such as: 
            'robin' (Robinson)
            'wintri' (Winkel Tripel)
            'mill' (Miller)
            'moll' (Mollweide)
            Using an invalid projection (string) raises a ValueError.
        lat (float): Latitude (degrees)
        lon (float): Longitude (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj={projection} +lon_0={lon} +x_0=0 +y_0=0 +datum=WGS84 +ellps=WGS84 +units=m +no_defs'
    description = f"Custom {projection} centered on lon {lon}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if not crs.isValid():
        #print("Invalid CRS")
        raise ValueError("Invalid CRS")
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description  

def crs_lcc(lat_1=33, lat_2=45, lon_0=0, setproject=False, savecrs=False):
    """
    Create a custom Lambert conformal conic (LCC)  projection with standard parallels lat_1 and lat_2. 
    
    Parameters:
        lat_1 (float): First standard parallel (degrees)
        lat_2 (float): Second standard parallel (degrees)
        lon_0=0 (float): Longitude of map center (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=lcc +lon_0={lon_0} +lat_1={lat_1} +lat_2={lat_2} +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
    description = f"LCC w. parallels {lat_1}, {lat_2}, centered lon {lon_0}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description   




def crs_albers(lat_1, lat_2, lon_0=0, setproject=False, savecrs=False):
    """
    Create a custom Albers equal-area conic projection with standard parallels lat_1 and lat_2. 
    
    Note: The greatest accuracy is obtained if the selected standard parallels enclose two-thirds the height of the map.
    Parameters:
        lat_1 (float): First standard parallel (degrees)
        lat_2 (float): Second standard parallel (degrees)
        lon_0=0 (float): Longitude of map center (degrees)
        setproject=False: Use the CRS to set the project CRS
        savecrs=False: Save the custom CRS in the database 
    Returns:
        crs (QgsCoordinateReferenceSystem)
        description (str)
    """
    proj4 = f'+proj=aea +lon_0={lon_0} +lat_1={lat_1} +lat_2={lat_2} +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
    description = f"Albers w. parallels {lat_1}, {lat_2}, centered lon {lon_0}"
    
    crs = QgsCoordinateReferenceSystem()
    crs.createFromProj4(proj4)
    
    if not crs.isValid():
        raise ValueError('Invalid input values') 
        
    if savecrs:
        save_crs(crs, description)
    if setproject:
        set_project_crs(crs)
    return crs, description   
  
    
def set_project_crs(crs):
    """Set the project crs. Parameter: crs (QgsCoordinateReferenceSystem)"""
    if crs.isValid():
        QgsProject.instance().setCrs(crs)
        print("Project CRS has been changed")
    else:
        print("Invalid CRS")
        
def save_crs(crs, description):
    """
    Save a crs in the user crs database.
    
    A valid CRS that is not yet in the database will be saved to the user database
    Parameters:
        crs (QgsCoordinateReferenceSystem)
        Description (str)
    """
    if not crs.isValid():
        print("Invalid CRS")
    elif crs.findMatchingProj():
        print("CRS already in Database")
    else:
        success = crs.saveAsUserCrs(description)
        if success:
            print("Succesfully saved CRS")
        else:
            print("Could not save CRS")

def get_project_crs():
    """Shortcut to get current project CRS. Returns: crs (QgsCoordinateReferenceSystem)"""
    return QgsProject.instance().crs()
    
class AreaOfInterest():
    """
    Rectangular area of interest with methods to create matching custom CRS.
    
    Area of Interest is the extent of the active layer, or, 
    if features are selected, the bounding box of these features.
    
    Methods:
        orthographic: Return custom orthographic projection.
        sat: Return custom satellite view projection.
        laea: Return custom Lambert azimuthal equal-area projection.
        lcc: Return custom Lambert conformal conic projection.
        albers: Return custom Albers equal-area conic projection.
        save_crs: Save the crs that was created last. 
    
    Attributes:
        box: Area of Interest as QgsRectangle.
        center: Center of the Area of Interest (QgsPointXY).
        lon: Longitude of central point (float).
        lat: Latitude of central point (float).
        lat_1, lat_2: Two standard parallel enclosing 2/3 of the AOI (float).
        crs: The last CRS that was created.
        crs_desc: Description of the last CRS that was created.
        setproject: Boolean, default is True, set to false if you don't want to set the project CRS while creating a custom CRS.
    """
        
    
    def __init__(self):
        layer = iface.activeLayer()
        if isinstance(layer, QgsVectorLayer) and layer.selectedFeatureCount() > 0:
            self.box = layer.boundingBoxOfSelected()
        else:
            self.box = layer.extent()
        
        self.center = self.box.center()
        self.lon = self.center.x()
        self.lat = self.center.y()
        
        # Keep reference of the last created CRS
        self.crs = None
        self.crs_desc = None
        
        # Set the project CRS to newly created CRS?
        self.setproject = True
        
        # Define two standard parallels enclosing 2/3 of the AOI
        
        self.lat_1 = self.box.yMaximum() - (self.box.height() / 6)
        self.lat_2 = self.box.yMinimum() + (self.box.height() / 6)
        
    def orthographic(self, lat=None, lon=None, round_digits=None):
        """
        Create a custom orthographic projection centered on center of 
        area of interest (with lat, lon = None) or on lat, lon. 
        
        This projections mimics the view of earth from space from infinite distance.
        Parameters:
            lat (float or None): Latitude (degrees)
            lon (float or None): Longitude (degrees)
            round_digits (int or None): optionally round lat, lon values.  

        Returns:
            crs (QgsCoordinateReferenceSystem)
            description (str)
        """
        # The default values are taken from the AOI attributes
        # but we allow to override them
        if not lat:
            lat = self.lat
        if not lon:
            lon = self.lon
        
        #Optionally round digits
        if round_digits != None:
            lat = round(lat, round_digits)
            lon = round(lon, round_digits)
        
        self.crs, self.crs_desc = crs_orthographic(lat=lat, lon=lon, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs
        
    def sat(self, lat=None, lon=None, h=5000000, azi=0, tilt=0, round_digits=None):
        if not lat:
            lat = self.lat
        if not lon:
            lon = self.lon

        #Optionally round digits
        if round_digits != None:
            lat = round(lat, round_digits)
            lon = round(lon, round_digits)
        
        self.crs, self.crs_desc = crs_sat(lat=lat, lon=lon, h=h, azi=azi, tilt=tilt, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs 
        
    def laea(self, lat=None, lon=None, round_digits=None):
        if not lat:
            lat = self.lat
        if not lon:
            lon = self.lon

        #Optionally round digits
        if round_digits != None:
            lat = round(lat, round_digits)
            lon = round(lon, round_digits) 
        
        self.crs, self.crs_desc = crs_laea(lat=lat, lon=lon, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs    
    
    def lcc(self, lat_1=None, lat_2=None, lon_0=None, round_digits=None):
        if not lat_1:
            lat_1 = self.lat_1
        if not lat_2:
            lat_2 = self.lat_2
        if not lon_0:
            lon_0 = self.lon

        #Optionally round digits
        if round_digits != None:
            lat_1 = round(lat_1, round_digits)
            lat_2 = round(lat_2, round_digits)
            lon_0 = round(lon_0, round_digits) 
        
        self.crs, self.crs_desc = crs_lcc(lat_1=lat_1, lat_2=lat_2, lon_0=lon_0, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs  
    
    
    def albers(self, lat_1=None, lat_2=None, lon_0=None, round_digits=None):
        if not lat_1:
            lat_1 = self.lat_1
        if not lat_2:
            lat_2 = self.lat_2
        if not lon_0:
            lon_0 = self.lon

        #Optionally round digits
        if round_digits != None:
            lat_1 = round(lat_1, round_digits)
            lat_2 = round(lat_2, round_digits)
            lon_0 = round(lon_0, round_digits) 
        
        self.crs, self.crs_desc = crs_albers(lat_1=lat_1, lat_2=lat_2, lon_0=lon_0, setproject=self.setproject)
        print(self.crs_desc)
        return self.crs 
        
    def save_crs(self):
        save_crs(self.crs, self.crs_desc)

    